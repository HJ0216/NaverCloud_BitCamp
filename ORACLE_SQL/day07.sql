-- EX1
CREATE OR REPLACE VIEW V_VIEW1
AS SELECT EMPLOYEE_ID, LAST_NAME, SALARY, DEPARTMENT_ID FROM EMPLOYEES
WHERE DEPARTMENT_ID=90;

SELECT * FROM V_VIEW1;
DELETE FROM V_VIEW1;

-- EX2
SELECT * FROM V_VIEW2;
UPDATE V_VIEW2 SET SALARY=12000 WHERE EMPLOYEE_ID=103;

SELECT * FROM V_VIEW2;
SELECT * FROM EMPLOYEES WHERE EMPLOYEE_id=103;

UPDATE EMPLOYEES SET SALARY=9000 WHERE EMPLOYEE_ID=103;
SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID=103;
SELECT * FROM V_VIEW2;


-- EX3
CREATE OR REPLACE VIEW V_VIEW5
AS SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID='IT_PROG'
WITH READ ONLY;

SELECT * FROM V_VIEW5;
DELETE FROM V_VIEW5;
UPDATE V_VIEW5 SET LAST_NAME='홍길동' WHERE EMPLOYEE_ID=103;

CREATE OR REPLACE VIEW V_VIEW6
AS SELECT EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID='IT_PROG'
WITH CHECK OPTION;

SELECT * FROM V_VIEW6;

INSERT INTO V_VIEW6(EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID)
VALUES(500,'kim','candy','2004-01-01','Sales');

UPDATE V_VIEW6 SET JOB_ID='Sales' WHERE EMPLOYEE_ID=103;

INSERT INTO V_VIEW6(EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID)
VALUES(00,'kim','candy','2004-01-01','IT_PROG');

SELECT * FROM V_VIEW6;
DELETE FROM V_VIEW6;


-- EX5
CREATE OR REPLACE VIEW V_VIEW7("부서 ID", "부서 평균")
AS SELECT NVL(DEPARTMENT_ID, 5000),
          ROUND(AVG(SALARY), -3)
     FROM EMPLOYEES
 GROUP BY DEPARTMENT_ID
 ORDER BY DEPARTMENT_ID;
 
SELECT * FROM V_VIEW7;


SELECT "부서 ID", "부서 평균"
FROM(SELECT NVL(DEPARTMENT_ID, 5000) "부서 ID",
            ROUND(AVG(SALARY), -3) "부서 평균"
            FROM EMPLOYEES
            GROUP BY DEPARTMENT_ID
            ORDER BY DEPARTMENT_ID);


-- EX6
SELECT ROWNUM, LAST_NAME, SALARY
  FROM(SELECT LAST_NAME, NVL(SALARY, 0) SALARY
         FROM EMPLOYEES
     ORDER BY 2 DESC)
 WHERE ROWNUM<=3;


-- EX7
SELECT ROWNUM, LAST_NAME, SALARY
  FROM (SELECT LAST_NAME, NVL(SALARY, 0) SALARY
          FROM EMPLOYEES
      ORDER BY 2 DESC)
 WHERE ROWNUM=1;
 
 
 -- EX8
 SELECT * FROM(SELECT ROWNUM, CEIL(ROWNUM/3) AS PAGE, TT.*
                 FROM (SELECT LAST_NAME, NVL(SALARY, 0) SALARY
                         FROM EMPLOYEES
                     ORDER BY SALARY DESC) TT)
         WHERE PAGE=2;            

SELECT * FROM (SELECT ROWNUM RN, TT.*
                FROM (SELECT LAST_NAME, NVL(SALARY, 0) SALARY
                        FROM EMPLOYEES
                    ORDER BY SALARY DESC) TT)
        WHERE RN BETWEEN 4 AND 6;


-- 문제1
CREATE OR REPLACE VIEW EMP_VIEW(사원ID, 사원이름, 급여, 부서ID) -- ALIAS 지정
             AS SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
                  FROM EMPLOYEES
                 WHERE SALARY BETWEEN 5000 AND 10000;

SELECT * FROM EMP_VIEW;


-- 문제2
SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS;
SELECT * FROM LOCATIONS;

CREATE VIEW VIEW_EMP_DEPT(사원번호, 사원명, 부서명)
  AS SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_NAME
       FROM EMPLOYEES E, DEPARTMENTS D
      WHERE D.DEPARTMENT_ID IN(10, 90)
   ORDER BY 1;

CREATE VIEW VIEW_EMP_DEPT(사원번호, 사원명, 부서명)
  AS SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_NAME
       FROM EMPLOYEES
       JOIN DEPARTMENTS USING(DEPARTMENT_ID)
      WHERE DEPARTMENT_ID IN(10, 90)
      ORDER BY 1;


-- 문제3
CREATE VIEW VIEW_EMP_DEPT2(사원번호, 사원명, 급여, 입사일, 부서명, "부서위치(city)")
-- ()때문에 ALIAS 지정이 되지 않을 경우, ""로 묶어주기
 AS SELECT EMPLOYEE_ID,
           FIRST_NAME,
           TO_CHAR(TRUNC(SALARY, -3),'99,999')||'원',
          -- ALIAS 미 지정 시, VIEW 객체로 가져오는 COL_NAME이 실제 COL NAME과 일치 : AS로 COL NAME 지정 필요
          -- ALIAS 지정 시, VIEW 객체의 COL NAME이 BASE TABLE과 다르므로 문제 발생 X
           TO_CHAR(HIRE_DATE, 'YYYY"년" MM"월" DD"일"'),
           DEPARTMENT_NAME,
           CITY
      FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L
  ORDER BY 1;

CREATE VIEW VIEW_EMP_DEPT3
  AS SELECT EMPLOYEE_ID,
            LAST_NAME,
            TO_CHAR(TRUNC(SALARY, -3),'99,999')||'원' SALARY,
            TO_CHAR(HIRE_DATE, 'YYYY"년" MM"월" DD"일"') HIRE_DATE,
            DEPARTMENT_NAME,
            CITY
       FROM EMPLOYEES
  LEFT JOIN DEPARTMENTS USING(DEPARTMENT_ID)
       JOIN LOCATIONS USING(LOCATION_ID)
      WHERE DEPARTMENT_ID IN (10, 90)
   ORDER BY 1;

SELECT * FROM VIEW_EMP_DEPT2;


-- 문제4
CREATE TABLE BOOKSHOP(
    ISBN VARCHAR2(10) CONSTRAINT PK_ISBN PRIMARY KEY,
    TITLE VARCHAR2(50) CONSTRAINT CHK_TITLE NOT NULL,
    AUTHOR VARCHAR2(50),
    PRICE NUMBER,
    COMPANY VARCHAR2(30)
);

INSERT INTO BOOKSHOP VALUES('ISOO1', '자바 3일 완성', '김자바', 25000, '야메루출판사');
INSERT INTO BOOKSHOP VALUES('ISOO2', 'JSP 달인되기', '이달인', 28000, '공갈닷컴');
INSERT INTO BOOKSHOP VALUES('ISOO3', '오라클 무작정 따라하기', '박따라', 23500, '야메루출판사');

COMMIT;

SELECT * FROM BOOKSHOP;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME='BOOKSHOP';


CREATE TABLE BOOKORDER(
                       IDX NUMBER CONSTRAINT PK_IDX PRIMARY KEY,
                       -- 제약 조건명을 입력하지 않을 경우에는 CONSTRAINT를 생략해서 IDX NUMBER PRIMARY KEY 입력
                       ISBN VARCHAR2(10),
                       -- ISBN VARCHAR2(10) CONSTRAINT FK_ISBN REFERENCES BOOKSHOP,
                       -- FK 선언을 하지 않을 경우, 옆에 짧게 작성할 수 있음
                       QTY NUMBER,
                       CONSTRAINT FK_ISBN FOREIGN KEY(ISBN) REFERENCES BOOKSHOP ON DELETE SET NULL
                      );
-- CONSTRAINT FK_ISBN FOREIGN KEY(ISBN) REFERENCES BOOKSHOP ON DELETE SET NULL
-- ISBN VARCHAR2(10)와 독립된 문장, PK와 선언 방법이 다름


SELECT * FROM USER_CONSTRAINTS
        WHERE TABLE_NAME='BOOKORDER';

CREATE SEQUENCE SEQ_IDX INCREMENT BY 2 START WITH 1 NOCACHE NOCYCLE;
-- INCREMENT, START WITH DEFAULT 1: 생략 가능

INSERT INTO BOOKORDER VALUES(SEQ_IDX.NEXTVAL, 'ISOO1', 2);
INSERT INTO BOOKORDER VALUES(SEQ_IDX.NEXTVAL, 'ISOO3', 3);
INSERT INTO BOOKORDER VALUES(SEQ_IDX.NEXTVAL, 'ISOO2', 5);
INSERT INTO BOOKORDER VALUES(SEQ_IDX.NEXTVAL, 'ISOO1', 3);
INSERT INTO BOOKORDER VALUES(SEQ_IDX.NEXTVAL, 'ISOO3', 10);

SELECT SEQ_IDX.NEXTVAL FROM DUAL;

SELECT * FROM BOOKORDER;

CREATE VIEW VIEW_BS(책제목, 저자, 총판매금액)
  AS SELECT TITLE, AUTHOR, TO_CHAR(SUM(QTY*PRICE),'999,999')
       FROM BOOKORDER
  LEFT JOIN BOOKSHOP USING(ISBN)  
   GROUP BY TITLE, AUTHOR
   -- GROUP BY에 사용된 COL만 SELECT할 수 있으므로 GROUP BY에서 TITLE, AUTHOR 기재
   -- SET로 묶어주려면 ()로 묶어주기
       WITH READ ONLY
;

SELECT * FROM VIEW_BS;


-- 문제5
SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS;

SELECT DEPARTMENT_NAME, MAX(SALARY)
FROM EMPLOYEES
JOIN DEPARTMENTS USING(DEPARTMENT_ID)
GROUP BY DEPARTMENT_NAME;

SELECT 이름, 부서명, 최대급여
FROM (SELECT LAST_NAME 이름,
             DEPARTMENT_NAME 부서명,
             SALARY 최대급여
        FROM EMPLOYEES
        JOIN DEPARTMENTS USING(DEPARTMENT_ID)
       WHERE (DEPARTMENT_ID, SALARY)
          IN (SELECT DEPARTMENT_ID, MAX(SALARY) AS 최대급여 FROM EMPLOYEES GROUP BY DEPARTMENT_ID))
    -- = ANY (SELECT DEPARTMENT_ID, MAX(SALARY) AS 최대급여 FROM EMPLOYEES GROUP BY DEPARTMENT_ID))
          -- 다중 COL의 결과(부서명, 최대급여)를 한 번에 RETURN하고자 할 경우, IN 연산자 활용
;

SELECT 이름, 부서명, 최대급여
FROM(SELECT LAST_NAME AS 이름, DEPARTMENT_NAME AS 부서명, SALARY AS 최대급여
       FROM EMPLOYEES
       JOIN DEPARTMENTS USING(DEPARTMENT_ID)
      WHERE (DEPARTMENT_ID, SALARY) = ANY (SELECT DEPARTMENT_ID, MAX(SALARY) AS SALARY 
                                             FROM EMPLOYEES 
                                         GROUP BY DEPARTMENT_ID)
     );

SELECT DEPARTMENT_ID, MAX(SALARY) AS 최대급여 FROM EMPLOYEES GROUP BY DEPARTMENT_ID;


-- 문제6
SELECT * FROM
(SELECT ROWNUM "RN", A.*
   FROM (SELECT FIRST_NAME "사원명",
                DEPARTMENT_NAME "부서명",
                TO_CHAR(SALARY*12*(1+NVL(COMMISSION_PCT,0)), 'L999,999') "연봉"
           FROM EMPLOYEES
           JOIN DEPARTMENTS USING(DEPARTMENT_ID)
       ORDER BY 3) A)
WHERE RN BETWEEN 2 AND 6
;
-- 상기 SQL 구문을 사용할 경우, ROWNUM을 COL로 지정하였으므로 ROWNUM이 2이상일 경우에도 사용 가능


SELECT A.*
FROM (SELECT FIRST_NAME "사원명",
             DEPARTMENT_NAME "부서명",
             TO_CHAR(SALARY*12*(1+NVL(COMMISSION_PCT,0)), 'L999,999') "연봉"
        FROM EMPLOYEES
        JOIN DEPARTMENTS USING(DEPARTMENT_ID)
    ORDER BY 3) A
WHERE ROWNUM BETWEEN 1 AND 5
;
-- 단, 상기 SQL 구문을 사용할 경우, ROWNUM은 SQL 구문 실행 시마다 1부터 시작하므로 ROWNUM이 2이상일 경우에는 결과값을 반환 X


-- 실습
 * hr 계정
GRANT ALL ON EMPLOYEES TO c##java;
-- EMPLOYEES TABLE에 대해서 JAVA 계정에게 사용 권한 부여

 * java 계정
-- HR 계정에서 EMPLOYEES TABLE에 대해서 JAVA 계정에게 사용 권한 부여
-- GRANT ALL ON EMPLOYEES TO c##java;
CREATE SYNONYM HR_EMP FOR HR.EMPLOYEES;
-- ORA-01031: 권한이 불충분합니다

-- SYSTEM 계정에서 SYNONYM 권한 부여 필요
-- GRANT CREATE SYNONYM TO c##java;

CREATE SYNONYM HR_EMP FOR HR.EMPLOYEES;

SELECT * FROM HR_EMP; -- ALIAS
SELECT * FROM HR.EMPLOYEES; -- FULL NAME

SELECT * FROM USER_SYNONYMS; -- TOTAL SYNONYMS 조회

DROP SYNONYM HR_EMP; -- SYNONYM DELETE

SELECT * FROM USER_SYNONYMS; -- TOTAL SYNONYMS 조회

 * SYSTEM 계정
GRANT CREATE SYNONYM TO c##java;
-- system 계정에서 SYNONYM 권한 부여


-- [문제]
 * hr 계정
GRANT ALL ON DEPARTMENTS TO c##java;
 * java 계정
CREATE SYNONYM HR_DEP FOR HR.DEPARTMENTS;
