-- EX1
SELECT TO_CHAR(TRUNC(AVG(SALARY), 0), 'L99,999') "사원 평균급여"
FROM EMPLOYEES;


-- EX2
SELECT DEPARTMENT_ID "부서 코드", TO_CHAR(ROUND(AVG(SALARY), 0), 'L99,999,999') "평균 급여"
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID HAVING AVG(SALARY) >= 5000
ORDER BY DEPARTMENT_ID ASC;


-- EX3
SELECT LAST_NAME, AVG(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;
-- 집계함수-SUM, AVG 등을 제외하고 group by절에 없는 것을 select에 조회하면 error


-- EX4
SELECT DEPARTMENT_ID, MAX(SALARY) "MAX_SALARY"
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING DEPARTMENT_ID IN (10, 20)
ORDER BY DEPARTMENT_ID;
-- 비효율: 전체 그룹화 후 10, 20 추려내기

SELECT DEPARTMENT_ID, MAX(SALARY) "MAX_SALARY"
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN(10, 20)
GROUP BY DEPARTMENT_ID
ORDER BY DEPARTMENT_ID;
-- 효율화: RECORD 당 ID가 10 OR 20을 먼저 추린 후 그룹화


-- EX5
SELECT EMPLOYEE_ID,
       EMPLOYEES.DEPARTMENT_ID,
       DEPARTMENT_NAME
FROM EMPLOYEES, DEPARTMENTS
WHERE EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;


-- EX6
SELECT E.LAST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+); -- LEFT JOIN

SELECT LAST_NAME, DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES
LEFT JOIN DEPARTMENTS USING(DEPARTMENT_ID);
-- ANSI에서는 FROM 절에 사용된 TABLE이 EMPLOYEES뿐


-- EX7
SELECT E.LAST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID; -- RIGHT JOIN

SELECT LAST_NAME, DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES
RIGHT JOIN DEPARTMENTS USING(DEPARTMENT_ID);


-- EX8
SELECT LAST_NAME, DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES
FULL JOIN DEPARTMENTS USING(DEPARTMENT_ID);


-- EX9
SELECT E.LAST_NAME, D.DEPARTMENT_ID, D.MANAGER_ID
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND E.MANAGER_ID=D.MANAGER_ID;

SELECT LAST_NAME, DEPARTMENT_ID, MANAGER_ID
FROM EMPLOYEES
INNER JOIN DEPARTMENTS USING(DEPARTMENT_ID, MANAGER_ID);


-- EX10
--테이블 복사 및 COL_NAME 변경
CREATE TABLE LOCATIONS2 AS SELECT * FROM LOCATIONS;
SELECT * FROM LOCATIONS;
SELECT * FROM LOCATIONS2;
ALTER TABLE LOCATIONS RENAME COLUMN LOCATION_ID TO LOC_ID;

SELECT D.DEPARTMENT_ID, L.CITY
FROM DEPARTMENTS D, LOCATIONS2 L
WHERE D.LOCATION_ID = L.LOC_ID;

SELECT DEPARTMENT_ID, CITY
FROM DEPARTMENTS
JOIN LOCATIONS2 ON(LOCATION_ID=LOC_ID);

SELECT DEPARTMENT_ID, CITY
FROM DEPARTMENTS D
JOIN LOCATIONS2 L ON(D.LOCATION_ID=L.LOC_ID);


-- EX11
SELECT EMPLOYEE_ID, MANAGER_ID, LAST_NAME FROM EMPLOYEES;
SELECT EMPLOYEE_ID, LAST_NAME FROM EMPLOYEES;

SELECT E.EMPLOYEE_ID "사원번호",
       E.LAST_NAME "사원명",
       M.LAST_NAME "관리자명"
FROM EMPLOYEES E, EMPLOYEES M
WHERE M.EMPLOYEE_ID=E.EMPLOYEE_ID;

SELECT E.EMPLOYEE_ID "사원번호",
       E.LAST_NAME "사원명",
       E.LAST_NAME "관리자명"
FROM EMPLOYEES E
JOIN EMPLOYEES M ON(M.EMPLOYEE_ID=E.EMPLOYEE_ID);


-- EX12
SELECT * FROM COUNTRIES, LOCATIONS;
SELECT * FROM COUNTRIES CROSS JOIN LOCATIONS;


-- EX13
CREATE TABLE SALGRADE(
SALVEL VARCHAR2(2),
LOWEST NUMBER,
HIGHEST NUMBER);

INSERT INTO SALGRADE VALUES('A', 20000, 29999);
INSERT INTO SALGRADE VALUES('B', 30000, 39999);
INSERT INTO SALGRADE VALUES('C', 0, 9999);

COMMIT;

SELECT * FROM SALGRADE;
SELECT * FROM EMPLOYEES;

SELECT EMPLOYEE_ID LAST_NAME, SALARY, SALVEL
FROM EMPLOYEES
JOIN SALGRADE ON(SALARY BETWEEN LOWEST AND HIGHEST) -- 10000 ~ 19999 제외
ORDER BY SALARY DESC, 1;


-- EX14
SELECT LAST_NAME, JOB_TITLE, DEPARTMENT_NAME
FROM EMPLOYEES
JOIN DEPARTMENTS USING(DEPARTMENT_ID)
JOIN JOBS USING(JOB_ID);


-- 문제1
SELECT JOB_ID, SUM(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID;


-- 문제2
SELECT DEPARTMENT_ID, CITY
from DEPARTMENTS D, LOCATIONS L
where D.location_ID = L.location_ID;

SELECT DEPARTMENT_ID, CITY
FROM DEPARTMENTS
JOIN LOCATIONS USING(LOCATOIN_ID);

SELECT DEPARTMENT_ID, CITY
FROM DEPARTMENTS, LOCATIONS
WHERE DEPARTMENT.LOCATION_ID = LOCATION.LOCATION_ID;


-- 문제3
CREATE TABLE LOCATOINS2 AS SELECT * FROM LOCATIONS;
SELECT * FROM LOCATIONS;
SELECT * FROM LOCATIONS2;
ALTER TABLE LOCATIONS RENAME COLUMN LOCATION_ID TO LOC_ID;

SELECT LAST_NAME "사원명", CITY "도시", DEPARTMENT_NAME "부서명"
FROM EMPLOYEES
JOIN DEPARTMENTS USING(DEPARTMENT_ID)
JOIN LOCATIONS2 ON(LOCATION_ID=LOC_ID)
WHERE CITY IN ('Seattle', 'Oxford') -- VALUE: 대소문자 구분
ORDER BY CITY, 1; -- COL_NAME 대신 CON_LOCATION 기재 가능


-- 문제4
SELECT EMPLOYEE_ID "사원번호",
       LAST_NAME || ' ' || FIRST_NAME "사원명",
       DEPARTMENT_NAME "부서명",
       CITY "도시",
       STREET_ADDRESS "도시주소",
       COUNTRY_NAME "나라이름"
FROM EMPLOYEES
LEFT JOIN DEPARTMENTS D USING(DEPARTMENT_ID) -- 모든 사원 포함
JOIN LOCATIONS2 L ON(D.LOCATION_ID=L.LOC_ID)
JOIN COUNTRIES C USING(COUNTRY_ID)
WHERE STREET_ADDRESS LIKE '%Ch%'
   OR STREET_ADDRESS LIKE '%Sh%'
   OR STREET_ADDRESS LIKE '%Rd%'
ORDER BY COUNTRY_NAME, 4;

SELECT * FROM EMPLOYEES;


[문제 추가]
-- 화학과를 제외하고 학과별로 학생들의 평점 평균(소수 이하 2자리)을 검색하세요
-- TABLE: STUDENT

SELECT * FROM STUDENT;

SELECT MAJOR, ROUND(AVG(AVR), 2)
FROM STUDENT
GROUP BY MAJOR
HAVING MAJOR!='화학';

SELECT MAJOR, ROUND(AVG(AVR), 2)
FROM STUDENT
WHERE MAJOR!='화학'
GROUP BY MAJOR;
-- SELECT / FROM / WHERE / GROUP BY / HAVING / ORDER BY


[문제 추가2]
-- 화학과를 제외한 각 학과별 평균 평점 중에 평점이 2.0 이상인 정보를 검색하세요
SELECT MAJOR, ROUND(AVG(AVR), 2)
FROM STUDENT
WHERE MAJOR!='화학'
GROUP BY MAJOR
HAVING ROUND(AVG(AVR), 2)>=2.0;

SELECT MAJOR, ROUND(AVG(AVR), 2)
FROM STUDENT
GROUP BY MAJOR
HAVING MAJOR!='화학' AND (ROUND(AVG(AVR), 2)>=2.0);
